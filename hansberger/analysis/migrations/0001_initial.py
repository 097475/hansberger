# Generated by Django 2.0.13 on 2019-06-05 13:43

import django.contrib.postgres.fields.jsonb
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('research', '0001_initial'),
        ('datasets', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='FiltrationAnalysis',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(help_text='Name this analysis', max_length=100)),
                ('slug', models.SlugField(max_length=110)),
                ('description', models.TextField(blank=True, help_text='Write a brief description of the analysis', max_length=500)),
                ('creation_date', models.DateTimeField(auto_now_add=True)),
                ('precomputed_distance_matrix', models.FileField(blank=True, default=None, help_text='Upload a precomputed distance matrix\n                                                   instead of selecting a dataset', null=True, upload_to='research/precomputed/')),
                ('window_size', models.PositiveIntegerField(blank=True, default=None, help_text="Leave window size blank to not use windows. Window parameter\n                                              is ignored when dealing with precomputed distance matrix. Always check\n                                              the dimensions of the dataset your are operating on and plan your windows\n                                              accordingly; eventual data that won't fit into the final window will be\n                                              discarded.", null=True)),
                ('window_overlap', models.PositiveIntegerField(default=0, help_text='How many columns of overlap to have in\n                                                 consequent windows, if windows are being used. It must be at most 1\n                                                 less than window size.')),
                ('filtration_type', models.CharField(choices=[('VRF', 'Vietoris Rips Filtration'), ('CWRF', 'Clique Weighted Rank Filtration')], help_text='Choose the type of analysis.', max_length=50)),
                ('distance_matrix_metric', models.CharField(blank=True, choices=[('braycurtis', 'Braycurtis'), ('canberra', 'Canberra'), ('chebyshev', 'Chebyshev'), ('cityblock', 'City block'), ('correlation', 'Correlation'), ('cosine', 'Cosine'), ('dice', 'Dice'), ('euclidean', 'Euclidean'), ('hamming', 'Hamming'), ('jaccard', 'Jaccard'), ('jensenshannon', 'Jensen Shannon'), ('kulsinski', 'Kulsinski'), ('mahalanobis', 'Mahalonobis'), ('matching', 'Matching'), ('minkowski', 'Minkowski'), ('rogerstanimoto', 'Rogers-Tanimoto'), ('russellrao', 'Russel Rao'), ('seuclidean', 'Seuclidean'), ('sokalmichener', 'Sojal-Michener'), ('sokalsneath', 'Sokal-Sneath'), ('sqeuclidean', 'Sqeuclidean'), ('yule', 'Yule')], help_text='If Vietoris-Rips filtration is selected and not using a precomputed distance matrix, choose the\n                  distance metric to use on the selected dataset. This parameter is ignored in all other cases.', max_length=20)),
                ('max_homology_dimension', models.PositiveIntegerField(default=1, help_text='Maximum homology dimension computed. Will compute all dimensions lower than and equal to this value.\n                                                 For 1, H_0 and H_1 will be computed.')),
                ('max_distances_considered', models.FloatField(blank=True, default=None, help_text='Maximum distances considered when constructing filtration.\n                                                 If blank, compute the entire filtration.', null=True)),
                ('coeff', models.PositiveIntegerField(default=2, help_text='Compute homology with coefficients in the prime field Z/pZ for\n                                p=coeff.')),
                ('do_cocycles', models.BooleanField(default=False, help_text='Indicator of whether to compute cocycles.')),
                ('n_perm', models.IntegerField(blank=True, default=None, help_text='The number of points to subsample in\n                                 a “greedy permutation,” or a furthest point sampling of the points. These points will\n                                 be used in lieu of the full point cloud for a faster computation, at the expense of\n                                 some accuracy, which can be bounded as a maximum bottleneck distance to all diagrams\n                                 on the original point set', null=True)),
                ('dataset', models.ForeignKey(blank=True, help_text='Select the source dataset from the loaded datasets', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='filtrationanalysis_requests_created', related_query_name='analysis', to='datasets.Dataset')),
                ('research', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='filtrationanalysis_requests_created', related_query_name='analysis', to='research.Research')),
            ],
            options={
                'verbose_name': 'filtration analysis',
                'verbose_name_plural': 'filtration analyses',
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='FiltrationWindow',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.PositiveIntegerField()),
                ('slug', models.SlugField(max_length=150)),
                ('creation_date', models.DateTimeField(auto_now_add=True)),
                ('start', models.PositiveIntegerField(blank=True, null=True)),
                ('end', models.PositiveIntegerField(blank=True, null=True)),
                ('result_matrix', django.contrib.postgres.fields.jsonb.JSONField(blank=True, null=True)),
                ('diagrams', django.contrib.postgres.fields.jsonb.JSONField(blank=True, null=True)),
                ('result_entropy', django.contrib.postgres.fields.jsonb.JSONField(blank=True, null=True)),
                ('analysis', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='windows', related_query_name='window', to='analysis.FiltrationAnalysis')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='MapperAnalysis',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(help_text='Name this analysis', max_length=100)),
                ('slug', models.SlugField(max_length=110)),
                ('description', models.TextField(blank=True, help_text='Write a brief description of the analysis', max_length=500)),
                ('creation_date', models.DateTimeField(auto_now_add=True)),
                ('precomputed_distance_matrix', models.FileField(blank=True, default=None, help_text='Upload a precomputed distance matrix\n                                                   instead of selecting a dataset', null=True, upload_to='research/precomputed/')),
                ('window_size', models.PositiveIntegerField(blank=True, default=None, help_text="Leave window size blank to not use windows. Window parameter\n                                              is ignored when dealing with precomputed distance matrix. Always check\n                                              the dimensions of the dataset your are operating on and plan your windows\n                                              accordingly; eventual data that won't fit into the final window will be\n                                              discarded.", null=True)),
                ('window_overlap', models.PositiveIntegerField(default=0, help_text='How many columns of overlap to have in\n                                                 consequent windows, if windows are being used. It must be at most 1\n                                                 less than window size.')),
                ('distance_matrix_metric', models.CharField(choices=[('braycurtis', 'Braycurtis'), ('canberra', 'Canberra'), ('chebyshev', 'Chebyshev'), ('cityblock', 'City block'), ('correlation', 'Correlation'), ('cosine', 'Cosine'), ('dice', 'Dice'), ('euclidean', 'Euclidean'), ('hamming', 'Hamming'), ('jaccard', 'Jaccard'), ('jensenshannon', 'Jensen Shannon'), ('kulsinski', 'Kulsinski'), ('mahalanobis', 'Mahalonobis'), ('matching', 'Matching'), ('minkowski', 'Minkowski'), ('rogerstanimoto', 'Rogers-Tanimoto'), ('russellrao', 'Russel Rao'), ('seuclidean', 'Seuclidean'), ('sokalmichener', 'Sojal-Michener'), ('sokalsneath', 'Sokal-Sneath'), ('sqeuclidean', 'Sqeuclidean'), ('yule', 'Yule')], default='euclidean', help_text='If not using a precomputed matrix, choose the distance metric to use on the dataset.', max_length=20)),
                ('projection', models.CharField(choices=[('sum', 'Sum'), ('mean', 'Mean'), ('median', 'Median'), ('max', 'Max'), ('min', 'Min'), ('std', 'Std'), ('dist_mean', 'Dist_mean'), ('l2norm', 'L2norm'), ('knn_distance_n', 'knn_distance_n')], default='sum', help_text='Specify a projection/lens type.', max_length=50)),
                ('scaler', models.CharField(choices=[('None', 'None'), ('MinMaxScaler', 'MinMaxScaler'), ('MaxAbsScaler', 'MaxAbsScaler'), ('RobustScaler', 'RobustScaler'), ('StandardScaler', 'StandardScaler')], default='MinMaxScaler', help_text='Scaler of the data applied after mapping. Use None for no scaling.', max_length=50)),
                ('use_original_data', models.BooleanField(default=False, help_text='If ticked, clustering is run on the original data,\n                                            else it will be run on the lower dimensional projection.')),
                ('clusterer', models.CharField(choices=[('k-means', 'K-Means'), ('affinity_propagation', 'Affinity propagation'), ('mean-shift', 'Mean-shift'), ('spectral_clustering', 'Spectral clustering'), ('agglomerative_clustering', 'StandardScaler'), ('DBSCAN', 'DBSCAN'), ('gaussian_mixtures', 'Gaussian mixtures'), ('birch', 'Birch')], default='DBSCAN', help_text='Select the clustering algorithm.', max_length=50)),
                ('cover_n_cubes', models.IntegerField(default=10, help_text='Number of hypercubes along each dimension.\n                                        Sometimes referred to as resolution.')),
                ('cover_perc_overlap', models.FloatField(default=0.5, help_text='Amount of overlap between adjacent cubes calculated\n                                           only along 1 dimension.')),
                ('graph_nerve_min_intersection', models.IntegerField(default=1, help_text='Minimum intersection considered when\n                                                       computing the nerve. An edge will be created only when the\n                                                       intersection between two nodes is greater than or equal to\n                                                       min_intersection')),
                ('precomputed', models.BooleanField(default=False, help_text='Tell Mapper whether the data that you are clustering on\n                                      is a precomputed distance matrix. If set to True, the assumption is that you are\n                                      also telling your clusterer that metric=’precomputed’ (which is an argument for\n                                      DBSCAN among others), which will then cause the clusterer to expect a square\n                                      distance matrix for each hypercube. precomputed=True will give a square matrix\n                                      to the clusterer to fit on for each hypercube.')),
                ('remove_duplicate_nodes', models.BooleanField(default=False, help_text='Removes duplicate nodes before edges are\n                                                 determined. A node is considered to be duplicate if it has exactly\n                                                 the same set of points as another node.')),
                ('dataset', models.ForeignKey(blank=True, help_text='Select the source dataset from the loaded datasets', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='mapperanalysis_requests_created', related_query_name='analysis', to='datasets.Dataset')),
                ('research', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='mapperanalysis_requests_created', related_query_name='analysis', to='research.Research')),
            ],
            options={
                'verbose_name': 'mapper algorithm analysis',
                'verbose_name_plural': 'mapper algoritm analyses',
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='MapperWindow',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.PositiveIntegerField()),
                ('slug', models.SlugField(max_length=150)),
                ('creation_date', models.DateTimeField(auto_now_add=True)),
                ('start', models.PositiveIntegerField(blank=True, null=True)),
                ('end', models.PositiveIntegerField(blank=True, null=True)),
                ('graph', models.TextField(blank=True, null=True)),
                ('analysis', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='windows', related_query_name='window', to='analysis.MapperAnalysis')),
            ],
            options={
                'abstract': False,
            },
        ),
        migrations.AlterUniqueTogether(
            name='mapperanalysis',
            unique_together={('slug', 'research')},
        ),
        migrations.AlterUniqueTogether(
            name='filtrationanalysis',
            unique_together={('slug', 'research')},
        ),
    ]
